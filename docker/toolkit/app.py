"""aichat-toolkit: dynamic custom tool host.

Each tool is a Python file in TOOLS_DIR.  The file must define:

    TOOL_NAME        str   - snake_case identifier
    TOOL_DESCRIPTION str   - shown to the LLM when deciding which tool to use
    TOOL_PARAMETERS  dict  - JSON Schema object for input parameters
    async def run(**kwargs) -> str  - implementation

Tools are discovered and reloaded on every request (2-second TTL cache).
The /register endpoint writes a new tool file and clears the cache so the
tool is immediately available in the same session.

Standard library and the following packages are available to tool code:
    asyncio, json, re, os, math, datetime, pathlib, textwrap,
    httpx (HTTP client), pydantic
"""
from __future__ import annotations

import asyncio
import importlib.util
import json
import logging
import os
import sys
import textwrap
import time
import traceback
from pathlib import Path
from typing import Any

import httpx
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
log = logging.getLogger("aichat-toolkit")

# ---------------------------------------------------------------------------
# Error reporting
# ---------------------------------------------------------------------------

_DATABASE_URL = os.environ.get("DATABASE_URL", "http://aichat-database:8091")
_SERVICE_NAME = "aichat-toolkit"


async def _report_error(message: str, detail: str | None = None) -> None:
    """Fire-and-forget: send an error entry to aichat-database."""
    try:
        async with httpx.AsyncClient(timeout=5) as client:
            await client.post(
                f"{_DATABASE_URL}/errors/log",
                json={"service": _SERVICE_NAME, "level": "ERROR",
                      "message": message, "detail": detail},
            )
    except Exception:
        pass  # never let error reporting crash the service


# ---------------------------------------------------------------------------
# Tool loading
# ---------------------------------------------------------------------------

TOOLS_DIR = Path("/data/tools")
TOOLS_DIR.mkdir(parents=True, exist_ok=True)

app = FastAPI(title="aichat-toolkit")

# ---------------------------------------------------------------------------
# In-process tool cache
# ---------------------------------------------------------------------------

_cache: dict[str, dict[str, Any]] = {}
_cache_stamp: float = 0.0
_CACHE_TTL = 2.0  # seconds


def _invalidate_cache() -> None:
    global _cache_stamp
    _cache_stamp = 0.0


def _load_tools() -> dict[str, dict[str, Any]]:
    global _cache, _cache_stamp
    now = time.monotonic()
    if now - _cache_stamp < _CACHE_TTL and _cache is not None:
        return _cache

    tools: dict[str, dict[str, Any]] = {}
    for path in sorted(TOOLS_DIR.glob("*.py")):
        mod_name = f"_aichat_tool_{path.stem}"
        try:
            # Remove any stale module from sys.modules so we always re-exec
            sys.modules.pop(mod_name, None)
            spec = importlib.util.spec_from_file_location(mod_name, path)
            if spec is None or spec.loader is None:
                continue
            mod = importlib.util.module_from_spec(spec)
            sys.modules[mod_name] = mod
            spec.loader.exec_module(mod)  # type: ignore[union-attr]
            name: str = getattr(mod, "TOOL_NAME", path.stem)
            desc: str = getattr(mod, "TOOL_DESCRIPTION", "No description.")
            params: dict = getattr(mod, "TOOL_PARAMETERS", {"type": "object", "properties": {}})
            if not hasattr(mod, "run") or not asyncio.iscoroutinefunction(mod.run):
                print(f"[toolkit] skip {path.name}: no async def run()")
                continue
            tools[name] = {
                "name": name,
                "description": desc,
                "parameters": params,
                "module": mod,
                "file": path.name,
            }
        except Exception:
            print(f"[toolkit] load error {path.name}:\n{traceback.format_exc()}")
    _cache = tools
    _cache_stamp = now
    return tools


# ---------------------------------------------------------------------------
# Module scaffold generator
# ---------------------------------------------------------------------------

_SCAFFOLD = '''\
"""Custom tool: {tool_name}"""
# Auto-generated by aichat-toolkit
import asyncio
import json
import math
import os
import re
import shlex
import subprocess
import textwrap
from datetime import datetime
from pathlib import Path

import httpx

# User repos are available at /data/repos (e.g. Path('/data/repos/myproject'))
REPOS_DIR = Path("/data/repos")

TOOL_NAME = {tool_name_repr}
TOOL_DESCRIPTION = {description_repr}
TOOL_PARAMETERS = {parameters_json}


async def run(**kwargs):
{code_body}
'''


def _build_module(
    tool_name: str,
    description: str,
    parameters: dict,
    code_body: str,
) -> str:
    # Ensure code_body is indented correctly (4 spaces minimum)
    lines = code_body.splitlines() or ["pass"]
    indented = "\n".join(
        ("    " + line) if line.strip() else ""
        for line in lines
    )
    return _SCAFFOLD.format(
        tool_name=repr(tool_name),
        tool_name_repr=repr(tool_name),
        description_repr=repr(description),
        parameters_json=json.dumps(parameters, indent=4),
        code_body=indented,
    )


# ---------------------------------------------------------------------------
# API models
# ---------------------------------------------------------------------------

class RegisterRequest(BaseModel):
    tool_name: str
    description: str
    parameters: dict = {}
    code: str  # body of async def run(**kwargs) -> str


class CallRequest(BaseModel):
    params: dict = {}


# ---------------------------------------------------------------------------
# Global exception handler — logs to aichat-database, never returns raw 500s
# ---------------------------------------------------------------------------

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    message = str(exc)
    detail = f"{request.method} {request.url.path}"
    log.error("Unhandled error [%s %s]: %s", request.method, request.url.path, exc, exc_info=True)
    asyncio.create_task(_report_error(message, detail))
    return JSONResponse(status_code=500, content={"error": message})


# ---------------------------------------------------------------------------
# Endpoints
# ---------------------------------------------------------------------------

@app.get("/health")
async def health() -> dict:
    return {"status": "ok", "tools_dir": str(TOOLS_DIR)}


@app.get("/tools")
async def list_tools() -> dict:
    tools = _load_tools()
    return {
        "tools": [
            {
                "name": t["name"],
                "description": t["description"],
                "parameters": t["parameters"],
                "file": t["file"],
            }
            for t in tools.values()
        ]
    }


@app.post("/register")
async def register_tool(req: RegisterRequest) -> dict:
    name = req.tool_name.strip()
    if not name or not name.replace("_", "").isalnum():
        raise HTTPException(
            status_code=400,
            detail="tool_name must be non-empty and contain only letters, digits, underscores",
        )

    module_src = _build_module(
        tool_name=name,
        description=req.description.strip(),
        parameters=req.parameters,
        code_body=req.code,
    )

    # Validate by compiling before writing
    try:
        compile(module_src, f"<{name}>", "exec")
    except SyntaxError as exc:
        raise HTTPException(status_code=422, detail=f"Syntax error in code: {exc}") from exc

    path = TOOLS_DIR / f"{name}.py"
    path.write_text(module_src, encoding="utf-8")
    _invalidate_cache()
    # Eagerly re-load to catch runtime import errors early
    tools = _load_tools()
    if name not in tools:
        error_msg = f"Tool '{name}' was written but failed to load — check the code."
        raise HTTPException(status_code=500, detail=error_msg)

    return {
        "registered": name,
        "file": path.name,
        "description": req.description,
    }


_TOOL_TIMEOUT = float(os.environ.get("TOOL_TIMEOUT", "30"))


@app.post("/call/{tool_name}")
async def call_tool(tool_name: str, req: CallRequest) -> dict:
    tools = _load_tools()
    if tool_name not in tools:
        raise HTTPException(status_code=404, detail=f"Tool '{tool_name}' not found")
    mod = tools[tool_name]["module"]
    try:
        result = await asyncio.wait_for(mod.run(**req.params), timeout=_TOOL_TIMEOUT)
        return {"tool": tool_name, "result": str(result)}
    except asyncio.TimeoutError:
        return {"tool": tool_name, "result": f"Tool timed out after {_TOOL_TIMEOUT:.0f}s", "error": True}
    except Exception:
        tb = traceback.format_exc()
        return {"tool": tool_name, "result": f"Tool error:\n{tb}", "error": True}


@app.delete("/tool/{tool_name}")
async def delete_tool(tool_name: str) -> dict:
    tools = _load_tools()
    if tool_name not in tools:
        raise HTTPException(status_code=404, detail=f"Tool '{tool_name}' not found")
    path = TOOLS_DIR / tools[tool_name]["file"]
    path.unlink(missing_ok=True)
    _invalidate_cache()
    return {"deleted": tool_name}
